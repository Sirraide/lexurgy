package com.meamoria.mpp.antlr

import com.meamoria.lexurgy.meta.java.MetaBaseVisitor
import com.meamoria.lexurgy.meta.java.MetaLexer
import com.meamoria.lexurgy.meta.java.MetaParser
import java.io.File

fun main(args: Array<String>) {
    if (args.isEmpty()) return
    BindingsUpdater(args[0]).generate()
}

class BindingsUpdater(private val inputFilePath: String) {
    private val inputFile = File(inputFilePath)
    private val grammarName = inputFile.nameWithoutExtension
    private val outGrammarName = grammarName + "Auto"
    private val packageName = inputFile.parentFile.name

    private val outputPath = "kotlin/com/meamoria/lexurgy/$packageName/Antlr$outGrammarName.kt"

    private val dontModify = "// This file is automatically generated from $grammarName.g4. Don't modify it!"
    private val packageDeclaration = "package com.meamoria.lexurgy.$packageName"
    private val antlrImport = "import com.meamoria.mpp.antlr.*"

    val grammar = MetaInterpreter().parseFile(inputFile.readText()) as MetaWalker.Grammar

    fun generate() {
        if (grammarName == "Meta") return

        generateCommon()
        generateJvm()
        generateJs()
    }

    fun generateCommon() {
        val outputCommon = File("src/commonMain/$outputPath")
        val commonText = listOf(
            dontModify,
            suppress("FunctionName", "unused"),
            packageDeclaration,
            antlrImport,
            "expect class ${outGrammarName}Lexer(input: CharStream) : Lexer",
            "expect class ${outGrammarName}Parser(input: TokenStream) : Parser {\n    " +
                    grammar.forEachRule("fun #lower#(): #upper#Context").joinToString("\n    ") +
                    "\n}",
            "expect open class ${outGrammarName}BaseVisitor<T>(){\n    fun visit(tree: ParseTree): T\n\n    " +
                    grammar.forEachRule("open fun visit#upper#(ctx: #upper#Context): T").joinToString("\n    ") +
                    "\n}",
        ).joinLines()
        outputCommon.writeText(commonText)
    }

    fun generateJvm() {
        val outputJvm = File("src/jvmMain/$outputPath")
        val jvmText = listOf(
            dontModify,
            packageDeclaration,
            """
                import com.meamoria.lexurgy.sc.java.LscBaseVisitor
                import com.meamoria.lexurgy.sc.java.LscLexer
                import com.meamoria.lexurgy.sc.java.LscParser
                import org.antlr.v4.runtime.tree.TerminalNode
            """.trimIndent(),
            "actual typealias ${outGrammarName}Lexer = ${grammarName}Lexer",
            "actual typealias ${outGrammarName}Parser = ${grammarName}Parser",
            "actual typealias ${outGrammarName}BaseVisitor<T> = ${grammarName}BaseVisitor<T>",
        ).joinLines()
        outputJvm.writeText(jvmText)
    }

    fun generateJs() {
        val outputJs = File("src/jsMain/$outputPath")
        val jsText = listOf(
            dontModify,
            suppress("FunctionName", "unused", "PropertyName"),
            packageDeclaration,
            antlrImport,
            "actual external class ${outGrammarName}Lexer actual constructor(input: CharStream): Lexer",
            "actual external class ${outGrammarName}Parser actual constructor(input: TokenStream) : Parser {\n    " +
                    grammar.forEachRule("actual fun #lower#(): #upper#Context").joinToString("\n    ") +
                    grammar.forEachRule(
                        "class #upper#FileContext : ParserRuleContext {#elements#}",
                        terminalTemplate = "fun #name#(): TerminalNode?",
                        singleTemplate = "fun #lower#(): #upper#Context",
                        optionalTemplate = "fun #lower#(): #upper#Context?",
                        listTemplate = "fun #lower#(): Array<#upper#Context>",
                    ) +
                    "\n}",
            "open external class ${outGrammarName}Visitor<T>(){\n    fun visit(tree: ParseTree): T\n\n    " +
                    grammar.forEachRule("open fun visit#upper#(ctx: #upper#Context): T").joinToString("\n    ") +
                    "\n}",
            "actual typealias ${outGrammarName}BaseVisitor<T> = ${outGrammarName}Visitor<T>",
        ).joinLines()
        outputJs.writeText(jsText)
    }
}

fun List<String>.joinLines(): String =
    joinToString(separator = "\n\n", postfix = "\n")

fun suppress(vararg names: String): String =
    "@file:Suppress(${names.joinToString(separator = "\", \"", prefix = "\"", postfix = "\"")})"

class MetaInterpreter {
    fun parseFile(text: String): MetaWalker.ParseNode {
        val inputStream = CharStreams.fromString(text)
        val lexer = MetaLexer(inputStream)
        val tokenStream = CommonTokenStream(lexer)
        val parser = MetaParser(tokenStream)
        val tree = parser.g4File()
        return MetaWalker.visit(tree)
    }
}

object MetaWalker : MetaBaseVisitor<MetaWalker.ParseNode>() {

    override fun visitG4File(ctx: MetaParser.G4FileContext): ParseNode =
        Grammar(listVisit(ctx.antlrRule()).map { it as AntlrRule })

    override fun visitAntlrRule(ctx: MetaParser.AntlrRuleContext): ParseNode =
        AntlrRule(
            ctx.ruleName().text,
            collectElements(visit(ctx.expression()) as Expression),
        )

    fun collectElements(expression: Expression): List<Element> =
        when (expression) {
            is Group -> collectElements(expression.expression)
            is Repeater -> when (expression.repeaterType) {
                RepeaterType.OPTIONAL -> collectElements(expression.expression).map { it.makeOptional() }
                else -> collectElements(expression.expression).map { it.makeList() }
            }
            is SequenceExpression -> expression.collectElements()
            is AltExpressions -> expression.collectElements()
            else -> throw AssertionError()
        }

    private fun listVisit(node: List<ParseTree>): List<ParseNode> =
        node.map { MetaWalker.visit(it) }

    interface ParseNode

    class Grammar(val rules: List<AntlrRule>) : ParseNode {
        fun forEachRule(
            template: String,
            terminalTemplate: String? = null,
            singleTemplate: String? = null,
            optionalTemplate: String? = null,
            listTemplate: String? = null,
        ): List<String> =
            rules.map {
                template.replaceLowerUpper(it.name)
                    .replace("#elements#", elements(
                        it,
                        terminalTemplate,
                        singleTemplate,
                        optionalTemplate,
                        listTemplate,
                    ))
            }

        fun elements(
            rule: AntlrRule,
            terminalTemplate: String?,
            singleTemplate: String?,
            optionalTemplate: String?,
            listTemplate: String?,
        ): String =
            rule.elements.mapNotNull {
                when (it) {
                    is TokenName -> terminalTemplate?.replace("name", it.name)
                    is SingleElement -> singleTemplate?.replaceLowerUpper(it.name)
                    is OptionalElement -> optionalTemplate?.replaceLowerUpper(it.name)
                    is ListElement -> listTemplate?.replaceLowerUpper(it.name)
                    else -> throw AssertionError()
                }
            }.joinToString("\n")

        fun String.replaceLowerUpper(replacement: String): String =
            replace("#lower#", replacement).replace("#upper#", replacement)
    }

    class AntlrRule(val name: String, val elements: List<Element>) : ParseNode

    interface Expression

    class Group(val expression: Expression) : Expression

    class Repeater(val expression: Expression, val repeaterType: RepeaterType) : Expression

    class SequenceExpression(val expressions: List<Expression>) : Expression {
        fun collectElements(): List<Element> =
            expressions.map { collectElements(it) }.matchNames { a, b -> a.sum(b) }
    }

    class AltExpressions(val expressions: List<Expression>) : Expression {
        fun collectElements(): List<Element> =
            expressions.map { collectElements() }.matchNames { a, b -> a.max(b) }
    }

    fun List<List<Element>>.matchNames(combiner: (Element, Element) -> Element): List<Element> =
        reduce { a, b ->
            val result = mutableListOf<Element>()
            val remaining = b.toMutableList()
            for (element in a) {
                val matchingIndex = b.indexOfFirst { it.name == element.name }
                if (matchingIndex >= 0) {
                    result += combiner(element, b[matchingIndex])
                    remaining.removeAt(matchingIndex)
                } else {
                    result += element
                }
            }
            result += remaining
            result
        }

    enum class RepeaterType {
        AT_LEAST_ONE,
        ANY_NUMBER,
        OPTIONAL,
    }

    interface Element {
        val name: String

        fun makeOptional(): Element

        fun makeList(): Element

        fun sum(other: Element): Element

        fun max(other: Element): Element
    }

    class TokenName(override val name: String) : Element {
        override fun makeOptional(): Element = this

        override fun makeList(): Element = this

        override fun sum(other: Element): Element = this

        override fun max(other: Element): Element = this
    }

    class SingleElement(override val name: String): Element {
        override fun makeOptional(): Element = OptionalElement(name)

        override fun makeList(): Element = ListElement(name)

        override fun sum(other: Element): Element = ListElement(name)

        override fun max(other: Element): Element = other
    }

    class OptionalElement(override val name: String): Element {
        override fun makeOptional(): Element = this

        override fun makeList(): Element = ListElement(name)

        override fun sum(other: Element): Element = ListElement(name)

        override fun max(other: Element): Element =
            when (other) {
                is SingleElement -> this
                else -> other
            }
    }

    class ListElement(override val name: String): Element {
        override fun makeOptional(): Element = this

        override fun makeList(): Element = this

        override fun sum(other: Element): Element = this

        override fun max(other: Element): Element = this
    }
}
